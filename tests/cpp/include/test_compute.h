/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */

/*!
 * \file test_op.h
 * \brief operator unit test utility functions
 * \author Chris Olivier
 *
 * These classes offer a framework for developing, testing and debugging operators
 * in C++.  They work for both CPU and GPU modes, as well as offer a timing
 * infrastructure in order to test inidividual operator performance.
 *
 * Operator data can be validated against general logic,
 * stored scalar values (which can be generated by this code from an existing operator via
 * BasicOperatorData::dumpC(), as well as against each other (ie check that
 * GPU, CPU, MKL, and CUDNN operators produce the same output given the same input.
 *
 * test_util.h: General testing utility functionality
 * test_perf.h: Performance-related classes
 * test_op.h:   Operator-specific testing classes
 */
#ifndef TEST_COMPUTE_H_
#define TEST_COMPUTE_H_

#include "../../src/common/utils.h"

namespace mxnet {
namespace test {
namespace op {

class ComputeOp /*: public Operator*/ {
 public:
  ComputeOp(const OpContext &ctx, const nnvm::NodeAttrs& attrs)
    : attrs_(attrs)
      , forward_(nullptr)
      , backward_(nullptr) {
    // TODO(cjolivier01): Determine backward op from op
    //common::GetFCompute<FCompute>(attrs.op, "FCompute", ctx)
  }

  void Forward(const OpContext &ctx,
               const std::vector<TBlob> &in_data,
               const std::vector<OpReqType> &req,
               const std::vector<TBlob> &out_data,
               const std::vector<TBlob> &aux_states) {
    if(forward_) {
      forward_(attrs_, ctx, in_data, req, out_data);
    }
  }

  void Backward(const OpContext &ctx,
                const std::vector<TBlob> &out_grad,
                const std::vector<TBlob> &in_data,
                const std::vector<TBlob> &out_data,
                const std::vector<OpReqType> &req,
                const std::vector<TBlob> &in_grad,
                const std::vector<TBlob> &aux_states) {
    if(backward_) {
      backward_(attrs_, ctx, { in_data }, req, in_grad);
    }
  }

//  virtual std::string TypeString() const {
//    return "ComputeOp";
//  }

 protected:
  nnvm::NodeAttrs attrs_;
  FCompute        forward_;
  FCompute        backward_;
};

template<typename OperatorType>
class ComputeOpProp /*: public OperatorProperty*/ {

};

}  // namespace op
}  // namespace test
}  // namespace mxnet

#endif  // TEST_OP_H_
