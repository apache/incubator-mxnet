From 11158f8b8261517586ad0ba43e2bbb57f340f822 Mon Sep 17 00:00:00 2001
From: benhe2011 <benhe.che@gmail.com>
Date: Tue, 6 Aug 2019 16:40:08 -0700
Subject: [PATCH 2/3] modified mshadow to support separate dimension scales

---
 .../extension/spatial_upsampling_nearest.h    | 34 ++++++++++++-------
 src/operator/nn/upsampling-inl.h              | 33 +++++++++++++++---
 2 files changed, 49 insertions(+), 18 deletions(-)

diff --git a/3rdparty/mshadow/mshadow/extension/spatial_upsampling_nearest.h b/3rdparty/mshadow/mshadow/extension/spatial_upsampling_nearest.h
index 534fbdd9e..7c0430534 100644
--- a/3rdparty/mshadow/mshadow/extension/spatial_upsampling_nearest.h
+++ b/3rdparty/mshadow/mshadow/extension/spatial_upsampling_nearest.h
@@ -11,7 +11,7 @@
 namespace mshadow {
 namespace expr {
 
-/*! \brief nearest neighboor upsampling
+/*! \brief nearest neighbor upsampling
  *         out(x, y) = in(int(x / scale_x), int(y / scale_y))
  *  \tparam SrcExp source expression
  *  \tparam DType data type
@@ -24,23 +24,25 @@ struct UpSamplingNearestExp :
   /*! \brief source oprand */
   const SrcExp &src_;
   /*! \brief up sampling scale */
-  index_t scale_;
+  index_t scale_h_;
+  index_t scale_w_;
+
   /*! \brief constructor */
-  UpSamplingNearestExp(const SrcExp &src, index_t scale)
-    : src_(src), scale_(scale) {
+  UpSamplingNearestExp(const SrcExp &src, index_t scale_h, index_t scale_w)
+    : src_(src), scale_h_(scale_h), scale_w_(scale_w) {
     this->shape_ = ShapeCheck<srcdim, SrcExp>::Check(src_);
-    this->shape_[srcdim - 2] *= scale_;
-    this->shape_[srcdim - 1] *= scale_;
+    this->shape_[srcdim - 2] *= scale_h;
+    this->shape_[srcdim - 1] *= scale_w;
   }
 };
 
 
 template<typename SrcExp, typename DType, int etype>
 inline UpSamplingNearestExp<SrcExp, DType, ExpInfo<SrcExp>::kDim>
-upsampling_nearest(const Exp<SrcExp, DType, etype> &src, index_t scale) {
+upsampling_nearest(const Exp<SrcExp, DType, etype> &src, index_t scale_h, index_t scale_w) {
   TypeCheckPass<ExpInfo<SrcExp>::kDim >= 2>
     ::Error_Expression_Does_Not_Meet_Dimension_Req();
-  return UpSamplingNearestExp<SrcExp, DType, ExpInfo<SrcExp>::kDim>(src.self(), scale);
+  return UpSamplingNearestExp<SrcExp, DType, ExpInfo<SrcExp>::kDim>(src.self(), scale_h, scale_w);
 }
 
 template<typename SrcExp, typename DType, int srcdim>
@@ -48,23 +50,29 @@ struct Plan<UpSamplingNearestExp<SrcExp, DType, srcdim>, DType> {
  public:
   explicit Plan(const UpSamplingNearestExp<SrcExp, DType, srcdim> &e)
     : src_(MakePlan(e.src_)),
-      scale_(e.scale_),
+      scale_h_(e.scale_h),
+      scale_w_(e.scale_w),
       new_height_(e.shape_[srcdim - 2]),
-      src_height_(static_cast<index_t>(e.shape_[srcdim - 2] / e.scale_)) {}
+      //new_width_(e.shape_[srcdim - 1]),
+      src_height_(static_cast<index_t>(e.shape_[srcdim - 2] / e.scale_h_)) {}
+      //src_width_(static_cast<index_t>(e.shape_[srcdim - 1] / e.scale_w_)) {}
   MSHADOW_XINLINE DType Eval(index_t i, index_t j) const {
     const index_t x = j;
     const index_t y = i % new_height_;
     const index_t c = i / new_height_;
-    const index_t h = static_cast<index_t>(y / scale_);
-    const index_t w = static_cast<index_t>(x / scale_);
+    const index_t h = static_cast<index_t>(y / scale_h_);
+    const index_t w = static_cast<index_t>(x / scale_w_);
     return src_.Eval(c * src_height_ + h, w);
   }
 
  private:
   Plan<SrcExp, DType> src_;
-  const index_t scale_;
+  const index_t scale_h_;
+  const index_t scale_w_;
   const index_t new_height_;
+  const index_t new_width_;
   const index_t src_height_;
+  const index_t src_width_;
 };
 }  // namespace expr
 }  // namespace mshadow
diff --git a/src/operator/nn/upsampling-inl.h b/src/operator/nn/upsampling-inl.h
index 4fdfdb579..c1b7ff28a 100644
--- a/src/operator/nn/upsampling-inl.h
+++ b/src/operator/nn/upsampling-inl.h
@@ -105,21 +105,44 @@ void UpSamplingForward(const OpContext &ctx, const UpSamplingParam &param,
     for (int i = 0; i < param.num_args; ++i) {
       Tensor<xpu, 4, DType> data = in_data[i].get<xpu, 4, DType>(s);
       int end = begin + data.size(1);
-      int scale = out_data[up_enum::kOut].size(2)/in_data[i].size(2); //modify--two scales now
+      
+      //int scale = out_data[up_enum::kOut].size(2)/in_data[i].size(2); //modify--two scales now
+      int scale_h = out_data[up_enum::kOut].size(2)/in_data[i].size(2);//3rd dimension of TBlob (2nd from 4th dimension)
+      int scale_w = out_data[up_enum::kOut].size(1)/in_data[i].size(1);//4th dimension of TBlob (1st from 4th dimension) ->is this right???
+      
       if (param.multi_input_mode == up_enum::kSum) {
         if (i == 0) {
-          Assign(out, req[up_enum::kOut], upsampling_nearest(data, scale));
+
+          Assign(out, req[up_enum::kOut], upsampling_nearest(data, scale_h, scale_w)); //modify
+
         } else {
-          out += upsampling_nearest(data, scale);
+
+          out += upsampling_nearest(data, scale_h, scale_w); //modify
+
         }
       } else {
-        Assign(slice<1>(out, begin, end), req[up_enum::kOut], upsampling_nearest(data, scale));
+
+        Assign(slice<1>(out, begin, end), req[up_enum::kOut], upsampling_nearest(data, scale_h, scale_w)); //modify
+
       }
       begin = end;
     }
   } else {
     Tensor<xpu, 4, DType> data = in_data[up_enum::kData].get<xpu, 4, DType>(s);
-    Assign(out, req[up_enum::kOut], upsampling_nearest(data, param.scale));
+
+    int scale_h, scale_w;
+    if (param.scale.ndim() == 1) {
+      scale_h = param.scale[0];
+      scale_w = param.scale[0];
+    } else if (param.scale.ndim() == 2) {
+      scale_h = param.scale[0];
+      scale_w = param.scale[1];
+    } else if (param.scale.ndim() == 4) {
+      scale_h = param.scale[2];
+      scale_w = param.scale[3];
+    }
+    Assign(out, req[up_enum::kOut], upsampling_nearest(data, scale_h, scale_w)); //modify
+
   }
 }
 
-- 
2.20.1 (Apple Git-117)

